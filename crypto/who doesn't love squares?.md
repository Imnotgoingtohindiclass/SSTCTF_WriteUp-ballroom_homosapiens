# who doesn't love squares?
**Difficulty: Easy**
### Challenge:
I love squares, what about you?

## Solution:
We have to analyse the code in order for us to solve the challenge.
```python
keys = [getPrime(randint(10,64)) for _ in range(30)]
assert not any([keys.count(itm) > 1 for itm in keys])
```
The code above shows that the key is generated by 30 random prime numbers.
```python
key = 1

for itm in keys:
    key *= itm
del keys

assert gcd(key,bytes_to_long(flag)) == 1
```
The code above highlights that the greatest common denominator of the key and the the flag is 1, meaning the two numbers have no common factors other than one (the two numbers are co-prime).

```python
ct = key*(bytes_to_long(flag))**2 # I squared the flag, for extra security!
print(ct)

```
"I squared the flag, for extra security!" will be the downfall of this challenge. From here, we can tell that the flag is squared twice, while key remains at 1.
Hence, by deduction, the prime factors of the flag are squared, while the prime factors of the keys remain as normal.
With the number below as the ciphertext:
21620386644249171511647843928405875877630468616922645043995290166075591244818914811009016748641892295133899320346983775871391710114529732134959519267542420975476356983693498518505305376633042259062567385935975210667183315712350127774932057640816291513586981730604799468402444215671105729081855019002712164147150764582905688272280322785279902918214946389681805919689233289886572757637181284311788289685127926923533233740412378283318333626885752673197263250568762905333333580234113270255552987667442499219872656029017230613085045837144815054539360776238695228400765955134190712412175631195738546711436505076140925
We will find the prime factors of the number using this application called [alpertron](https://www.alpertron.com.ar/ECM.HTM).
Inputting the value into the box,
![alt text](/images/wdls_1.png)
We get this:
![alt text](/images/wdls_2.png)
After this, we take out all the square numbers, multiply them together, and use the python function `long_to_bytes()` on the number.
Thus, we get the flag **sstctf{make_sur3_y0ur_pr1m3_f4ctors_ar3_1ndiff3eren+i4bl3}**.